const myVersion = "0.4.1", myProductName = "userland";  

const fs = require ("fs");
const utils = require ("daveutils");
const mail = require ("davemail");
const daveappserver = require ("daveappserver"); 
const davesql = require ("davesql");

var config = {
	confirmEmailSubject: "UserLand confirmation",
	fnameEmailTemplate: "emailtemplate.html",
	operationToConfirm: "log onto UserLand",
	mailSender: "dave@scripting.com",
	dataFolder: "data/"
	};

var stats = {
	pendingConfirmations: new Array ()
	};
var flStatsChanged = false;
const fnameStats = "stats.json";

function removeNullValuesFromObject (obj) { //9/26/22 by DW
	for (var x in obj) { 
		if (obj [x] == null) {
			obj [x] = undefined;
			}
		}
	return (obj);
	}
function isUserInDatabase (screenname, callback) { //9/17/22 by DW
	const sqltext = "select * from users where screenname=" + davesql.encode (screenname) + ";";
	davesql.runSqltext (sqltext, function (err, result) {
		if (err) {
			callback (false);
			}
		else {
			if (result.length == 0) {
				callback (false);
				}
			else {
				callback (true, result [0]);
				}
			}
		});
	}
function setUserPrefs (screenname, jsontext, callback) { //9/15/22 by DW
	function normalizeCatString (s) {
		if (s == ",all,") {
			s = "All";
			}
		return (s);
		}
	var prefs;
	try {
		prefs = JSON.parse (jsontext);
		}
	catch (err) {
		callback (err);
		return;
		}
	const now = new Date ();
	var userRec = {
		screenname: maxStringLength (screenname, config.maxListNameLength),
		
		whenCreated: now,
		whenUpdated: now,
		
		ctStartups: prefs.ctStartups,
		whenLastStartup: new Date (prefs.whenLastStartup),
		
		};
	isUserInDatabase (screenname, function (flInDatabase, userRecFromDatabase) {
		if (flInDatabase) {
			if (userRecFromDatabase.whenCreated != null) {
				userRec.whenCreated = userRecFromDatabase.whenCreated
				}
			}
		const sqltext = "replace into users " + davesql.encodeValues (userRec);
		davesql.runSqltext (sqltext, function (err, result) {
			if (err) {
				callback (err);
				}
			else {
				callback (undefined, userRec);
				}
			});
		});
	}
function getUserPrefs (screenname, callback) { //9/26/22 by DW
	isUserInDatabase (screenname, function (flInDatabase, userRec) {
		if (flInDatabase) {
			callback (undefined, removeNullValuesFromObject (userRec));
			}
		else {
			callback ({message: "Can't get the prefs because there is no user named \"" + screenname + "\"."});
			}
		});
	}

function addUserToDatabase (email, password, callback) { //11/13/22 by DW
	const now = new Date ();
	const userRec = {
		email,
		password,
		
		ctStartups:  0,
		whenLastStartup: now,
		
		whenCreated: now, 
		whenUpdated: now,
		}
	
	const sqltext = "replace into users " + davesql.encodeValues (userRec);
	davesql.runSqltext (sqltext, function (err, data) {
		if (err) {
			if (callback !== undefined) {
				callback (err);
				}
			}
		else {
			if (callback !== undefined) {
				callback (undefined, userRec);
				}
			}
		});
	}

function statsChanged () {
	flStatsChanged = true;
	}
function sendConfirmingEmail (email, callback) {
	const magicString = utils.getRandomPassword (10);
	const urlWebApp = "http://" + config.myDomain + "/";
	console.log ("sendConfirmingEmail: email == " + email + ", urlWebApp == " + urlWebApp);
	var obj = {
		magicString: magicString,
		email: email,
		when: new Date ()
		};
	stats.pendingConfirmations.push (obj);
	statsChanged ();
	console.log ("sendConfirmingEmail: obj == " + utils.jsonStringify (obj));
	var params = {
		title: config.confirmEmailSubject,
		operationToConfirm: config.operationToConfirm,
		confirmationUrl: urlWebApp + "logon?emailConfirmCode=" + encodeURIComponent (magicString)
		};
	fs.readFile (config.fnameEmailTemplate, function (err, emailTemplate) {
		if (err) {
			console.log ("sendConfirmingEmail: err.message == " + err.message);
			}
		else {
			var mailtext = utils.multipleReplaceAll (emailTemplate.toString (), params, false, "[%", "%]");
			mail.send (email, params.title, mailtext, config.mailSender, function (err, data) {
				if (err) {
					callback (err);
					}
				else {
					callback (undefined, {message: "Please check your email."});
					}
				});
			const f = config.dataFolder + "lastmail.html";
			utils.sureFilePath (f, function () {
				fs.writeFile (f, mailtext, function (err) {
					});
				});
			}
		});
	}
function receiveConfirmation (emailConfirmCode, callback) {
	const urlWebApp = "http://" + config.myDomain + "/";
	var urlRedirect = undefined;
	stats.pendingConfirmations.forEach (function (item) {
		if (item.magicString == emailConfirmCode) {
			console.log (utils.jsonStringify (item));
			
			
			addUserToDatabase (item.email, item.magicString);
			
			urlRedirect = urlWebApp + "?email=" + item.email + "&code=" + item.magicString;
			}
		});
	if (urlRedirect === undefined) {
		urlRedirect = urlWebApp + "?failedLogin=true"; //add an error message here
		}
	console.log ("receiveConfirmation: urlRedirect == " + urlRedirect);
	callback (urlRedirect);
	}

function handleHttpRequest (theRequest) {
	var now = new Date ();
	const params = theRequest.params;
	const token = params.oauth_token;
	const secret = params.oauth_token_secret;
	function returnRedirect (url, code) { 
		var headers = {
			location: url
			};
		if (code === undefined) {
			code = 302;
			}
		theRequest.httpReturn (code, "text/plain", code + " REDIRECT", headers);
		}
		
	function returnPlainText (s) {
		theRequest.httpReturn (200, "text/plain", s.toString ());
		}
	function returnData (jstruct) {
		if (jstruct === undefined) {
			jstruct = {};
			}
		theRequest.httpReturn (200, "application/json", utils.jsonStringify (jstruct));
		}
	function returnJsontext (jsontext) { //9/14/22 by DW
		theRequest.httpReturn (200, "application/json", jsontext.toString ());
		}
	function returnError (jstruct) {
		theRequest.httpReturn (500, "application/json", utils.jsonStringify (jstruct));
		}
	function returnOpml (err, opmltext) {
		if (err) {
			returnError (err);
			}
		else {
			theRequest.httpReturn (200, "text/xml", opmltext);
			}
		}
	function httpReturn (err, returnedValue) {
		if (err) {
			returnError (err);
			}
		else {
			if (typeof returnedValue == "object") {
				returnData (returnedValue);
				}
			else {
				returnJsontext (returnedValue); //9/14/22 by DW
				}
			}
		}
	function xmlReturn (err, xmltext) { //9/17/22 by DW
		if (err) {
			returnError (err);
			}
		else {
			theRequest.httpReturn (200, "text/xml", xmltext);
			}
		}
	function callWithScreenname (callback) {
		davetwitter.getScreenName (token, secret, function (screenname) {
			if (screenname === undefined) {
				returnError ({message: "Can't do the thing you want because the accessToken is not valid."});    
				}
			else {
				callback (screenname);
				}
			});
		}
	switch (theRequest.method) {
		case "GET":
			switch (theRequest.lowerpath) {
				case "/sendconfirmingemail": //11/4/22 by DW
					sendConfirmingEmail (params.email, httpReturn);
					return (true);
				case "/logon":  //11/4/22 by DW
					receiveConfirmation (params.emailConfirmCode, returnRedirect);
					return (true);
				default: 
					return (false); //not consumed
				}
			break;
		}
	return (false); //not consumed
	}

function readStats (callback) {
	utils.sureFilePath (fnameStats, function () {
		fs.readFile (fnameStats, function (err, data) {
			if (!err) {
				try {
					var jstruct = JSON.parse (data.toString ());
					for (var x in jstruct) {
						stats [x] = jstruct [x];
						}
					}
				catch (err) {
					console.log ("readStats: err == " + err.message);
					}
				}
			if (callback !== undefined) {
				callback ();
				}
			});
		});
	}
function everySecond () {
	if (flStatsChanged) {
		fs.writeFile ("stats.json", utils.jsonStringify (stats), function (err) {
			if (err) {
				console.log (err.message);
				}
			});
		flStatsChanged = false;
		}
	}
function everyMinute () {
	}

readStats (function () {
	var options = {
		everySecond,
		everyMinute,
		httpRequest: handleHttpRequest
		}
	daveappserver.start (options, function (appConfig) {
		for (var x in appConfig) {
			config [x] = appConfig [x];
			}
		davesql.start (config.database);
		});
	});
